name: CI-CD

on:
  pull_request:
    branches: [ "main" ]
  push:
    branches: [ "main" ]
  workflow_dispatch:
    inputs:
      deploy:
        description: "수동 실행 시 CD까지 진행(true/false)"
        required: false
        default: "true"
      simulate_cd_fail:
        description: "CD 단계에서 강제 실패 재연(true/false)"
        required: false
        default: "false"

jobs:
  ci:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "17"

      - name: Gradle permission
        run: chmod +x ./gradlew

      - name: Test
        run: ./gradlew test

      - name: Build bootJar
        run: ./gradlew clean bootJar -x test

      - name: Upload artifact (jar)
        uses: actions/upload-artifact@v4
        with:
          name: app-jar
          path: build/libs/*.jar

  cd:
    needs: ci
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'push' && github.ref == 'refs/heads/main')
      || (github.event_name == 'workflow_dispatch' && github.ref == 'refs/heads/main' && (github.event.inputs.deploy || 'true') == 'true')

    steps:
      - name: Download artifact (jar)
        uses: actions/download-artifact@v4
        with:
          name: app-jar
          path: dist

      - name: Pick jar as app.jar
        shell: bash
        run: |
          set -euo pipefail
          ls -al dist
          JAR_PATH="$(ls -1 dist/*.jar | head -n 1)"
          echo "Picked: ${JAR_PATH}"
          cp "${JAR_PATH}" dist/app.jar
          ls -al dist

      - name: Install openssh-client + netcat (for debug)
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y openssh-client netcat-openbsd

      - name: Debug - show secrets presence (no values)
        shell: bash
        run: |
          set -euo pipefail
          [ -n "${{ secrets.SSH_HOST }}" ] && echo "SSH_HOST set" || (echo "SSH_HOST missing"; exit 1)
          [ -n "${{ secrets.SSH_PORT }}" ] && echo "SSH_PORT set" || (echo "SSH_PORT missing"; exit 1)
          [ -n "${{ secrets.SSH_USER }}" ] && echo "SSH_USER set" || (echo "SSH_USER missing"; exit 1)
          [ -n "${{ secrets.SSH_PRIVATE_KEY }}" ] && echo "SSH_PRIVATE_KEY set" || (echo "SSH_PRIVATE_KEY missing"; exit 1)

      - name: Prepare SSH files (key/known_hosts)
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh

          # private key (절대 echo로 여러줄 깨지게 하지 말고 printf로 쓴다)
          printf "%s" "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key

          HOST="${{ secrets.SSH_HOST }}"
          PORT="${{ secrets.SSH_PORT }}"

          # known_hosts
          if [ -n "${{ secrets.SSH_KNOWN_HOSTS }}" ]; then
            printf "%s\n" "${{ secrets.SSH_KNOWN_HOSTS }}" > ~/.ssh/known_hosts
          else
            # keyscan이 실패할 수 있으니 로그 남기고, 실패하면 여기서 중단시키고 싶으면 || true 제거하면 된다
            ssh-keyscan -p "${PORT}" -T 5 "${HOST}" > ~/.ssh/known_hosts || true
          fi
          chmod 600 ~/.ssh/known_hosts

          echo "known_hosts lines:"
          wc -l ~/.ssh/known_hosts || true
          echo "known_hosts preview:"
          head -n 3 ~/.ssh/known_hosts || true

      - name: Debug - DNS + TCP connectivity
        shell: bash
        run: |
          set -euo pipefail
          HOST="${{ secrets.SSH_HOST }}"
          PORT="${{ secrets.SSH_PORT }}"

          echo "Resolving host..."
          getent ahosts "${HOST}" || true

          echo "Checking TCP to ${HOST}:${PORT}"
          nc -vz -w 5 "${HOST}" "${PORT}"

      - name: Debug - SSH handshake (no command)
        shell: bash
        run: |
          set -euo pipefail
          HOST="${{ secrets.SSH_HOST }}"
          PORT="${{ secrets.SSH_PORT }}"
          USER="${{ secrets.SSH_USER }}"

          # StrictHostKeyChecking=yes를 유지하려면 known_hosts가 정상이어야 한다.
          ssh -i ~/.ssh/deploy_key -p "${PORT}" \
            -o BatchMode=yes \
            -o ConnectTimeout=7 \
            -o StrictHostKeyChecking=accept-new \
            "${USER}@${HOST}" "echo SSH_OK && whoami && hostname"

      - name: SCP jar to server incoming/app.jar (openssh scp)
        shell: bash
        run: |
          set -euo pipefail
          HOST="${{ secrets.SSH_HOST }}"
          PORT="${{ secrets.SSH_PORT }}"
          USER="${{ secrets.SSH_USER }}"

          scp -i ~/.ssh/deploy_key -P "${PORT}" \
            -o BatchMode=yes \
            -o ConnectTimeout=10 \
            -o StrictHostKeyChecking=accept-new \
            dist/app.jar "${USER}@${HOST}:/opt/githubactionPractice/incoming/app.jar"

      - name: Deploy on server (run deploy script)
        shell: bash
        run: |
          set -euo pipefail
          HOST="${{ secrets.SSH_HOST }}"
          PORT="${{ secrets.SSH_PORT }}"
          USER="${{ secrets.SSH_USER }}"
          SIM_FAIL="${{ github.event.inputs.simulate_cd_fail || 'false' }}"

          ssh -i ~/.ssh/deploy_key -p "${PORT}" \
            -o BatchMode=yes \
            -o ConnectTimeout=10 \
            -o StrictHostKeyChecking=accept-new \
            "${USER}@${HOST}" bash -lc "set -euo pipefail
              echo 'incoming listing:'
              ls -al /opt/githubactionPractice/incoming

              if [ '${SIM_FAIL}' = 'true' ]; then
                echo 'simulate_cd_fail=true -> forcing failure'
                exit 1
              fi

              /usr/local/bin/deploy_githubactionPractice.sh

              echo 'service status:'
              sudo systemctl status githubactionPractice --no-pager -l
            "
