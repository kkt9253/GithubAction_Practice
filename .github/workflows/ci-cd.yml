name: CI-CD

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:
    inputs:
      deploy:
        description: "수동 실행 시 CD까지 진행(true/false)"
        required: false
        default: "true"
      simulate_cd_fail:
        description: "CD 단계에서 강제 실패 재연(true/false)"
        required: false
        default: "false"

jobs:
  ci:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "17"

      - name: Gradle permission
        run: chmod +x ./gradlew

      - name: Test
        run: ./gradlew test

      - name: Build bootJar
        run: ./gradlew clean bootJar -x test

      - name: Upload artifact (jar)
        uses: actions/upload-artifact@v4
        with:
          name: app-jar
          path: build/libs/*.jar

  cd:
    needs: ci
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'push' && github.ref == 'refs/heads/main')
      || (github.event_name == 'workflow_dispatch' && github.ref == 'refs/heads/main' && (github.event.inputs.deploy || 'true') == 'true')

    steps:
      - name: Validate secrets exist (quick)
        shell: bash
        run: |
          set -e
          [ -n "${{ secrets.SSH_HOST }}" ] || (echo "Missing secret: SSH_HOST" && exit 1)
          [ -n "${{ secrets.SSH_PORT }}" ] || (echo "Missing secret: SSH_PORT" && exit 1)
          [ -n "${{ secrets.SSH_USER }}" ] || (echo "Missing secret: SSH_USER" && exit 1)
          [ -n "${{ secrets.SSH_PRIVATE_KEY }}" ] || (echo "Missing secret: SSH_PRIVATE_KEY" && exit 1)
          echo "Secrets present"

      - name: Debug - runner network info (public IP)
        shell: bash
        run: |
          set -euo pipefail
          echo "Runner date:"
          date
          echo "Runner outbound public IPs (may differ):"
          curl -sS https://api.ipify.org || true
          echo
          curl -sS https://ifconfig.me || true
          echo
          echo "Host/Port:"
          echo "SSH_HOST=${{ secrets.SSH_HOST }}"
          echo "SSH_PORT=${{ secrets.SSH_PORT }}"
          echo "SSH_USER=${{ secrets.SSH_USER }}"

      - name: Debug - DNS/resolve (even if host is IP)
        shell: bash
        run: |
          set -euo pipefail
          echo "getent hosts:"
          getent hosts "${{ secrets.SSH_HOST }}" || true
          echo "nslookup:"
          nslookup "${{ secrets.SSH_HOST }}" || true

      - name: Debug - TCP reachability to SSH port (critical)
        id: tcp
        shell: bash
        run: |
          set -euo pipefail
          HOST="${{ secrets.SSH_HOST }}"
          PORT="${{ secrets.SSH_PORT }}"

          echo "Checking TCP to ${HOST}:${PORT}"
          # nc는 timeout 시 exit!=0
          if timeout 6 bash -lc "nc -vz -w 5 ${HOST} ${PORT}"; then
            echo "nc: TCP OK"
            echo "ok=true" >> "$GITHUB_OUTPUT"
          else
            echo "nc: TCP FAIL"
            echo "ok=false" >> "$GITHUB_OUTPUT"
          fi

          echo "Also /dev/tcp check"
          if timeout 6 bash -lc "cat < /dev/null > /dev/tcp/${HOST}/${PORT}"; then
            echo "/dev/tcp: TCP OK"
            echo "ok2=true" >> "$GITHUB_OUTPUT"
          else
            echo "/dev/tcp: TCP FAIL"
            echo "ok2=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Debug - build ssh key files (do not fail on keyscan)
        if: steps.tcp.outputs.ok == 'true' || steps.tcp.outputs.ok2 == 'true'
        shell: bash
        run: |
          set -euo pipefail

          mkdir -p ~/.ssh
          chmod 700 ~/.ssh

          # private key (OpenSSH format 그대로 저장)
          cat > ~/.ssh/deploy_key <<'KEY'
          ${{ secrets.SSH_PRIVATE_KEY }}
          KEY
          chmod 600 ~/.ssh/deploy_key

          echo "Private key fingerprint (local):"
          ssh-keygen -lf ~/.ssh/deploy_key || true

          # known_hosts: secret 있으면 그걸 쓰고, 없으면 keyscan 시도(실패해도 진행)
          if [ -n "${{ secrets.SSH_KNOWN_HOSTS }}" ]; then
            echo "${{ secrets.SSH_KNOWN_HOSTS }}" > ~/.ssh/known_hosts
          else
            # keyscan은 네트워크 조금만 불안해도 exit 1 낼 수 있어서 || true 붙임
            ssh-keyscan -p "${{ secrets.SSH_PORT }}" -T 5 "${{ secrets.SSH_HOST }}" > ~/.ssh/known_hosts || true
          fi
          chmod 600 ~/.ssh/known_hosts

          echo "known_hosts lines:"
          wc -l ~/.ssh/known_hosts || true
          echo "known_hosts preview:"
          head -n 3 ~/.ssh/known_hosts || true

      - name: Debug - SSH handshake (verbose)
        if: steps.tcp.outputs.ok == 'true' || steps.tcp.outputs.ok2 == 'true'
        shell: bash
        run: |
          set -euo pipefail
          HOST="${{ secrets.SSH_HOST }}"
          PORT="${{ secrets.SSH_PORT }}"
          USER="${{ secrets.SSH_USER }}"

          echo "Trying SSH with -vvv (this is the most useful log)"
          # StrictHostKeyChecking은 known_hosts가 비어있으면 실패할 수 있음(그게 또 힌트)
          ssh -vvv \
            -i ~/.ssh/deploy_key \
            -p "${PORT}" \
            -o BatchMode=yes \
            -o ConnectTimeout=10 \
            -o ServerAliveInterval=5 \
            -o ServerAliveCountMax=1 \
            -o StrictHostKeyChecking=accept-new \
            "${USER}@${HOST}" 'echo "SSH_OK"; uname -a; whoami' || true

      - name: Download artifact (jar)
        if: steps.tcp.outputs.ok == 'true' || steps.tcp.outputs.ok2 == 'true'
        uses: actions/download-artifact@v4
        with:
          name: app-jar
          path: dist

      - name: Pick jar as app.jar
        if: steps.tcp.outputs.ok == 'true' || steps.tcp.outputs.ok2 == 'true'
        shell: bash
        run: |
          set -euo pipefail
          ls -al dist
          JAR_PATH="$(ls -1 dist/*.jar | head -n 1)"
          echo "Picked: ${JAR_PATH}"
          cp "${JAR_PATH}" dist/app.jar
          ls -al dist

      # appleboy 대신 표준 scp/ssh로 가면 디버깅이 훨씬 쉬움
      - name: SCP app.jar to server (key-only)
        if: steps.tcp.outputs.ok == 'true' || steps.tcp.outputs.ok2 == 'true'
        shell: bash
        run: |
          set -euo pipefail
          HOST="${{ secrets.SSH_HOST }}"
          PORT="${{ secrets.SSH_PORT }}"
          USER="${{ secrets.SSH_USER }}"

          scp -v -P "${PORT}" \
            -i ~/.ssh/deploy_key \
            -o BatchMode=yes \
            -o ConnectTimeout=10 \
            -o StrictHostKeyChecking=accept-new \
            dist/app.jar \
            "${USER}@${HOST}:/opt/githubactionPractice/incoming/app.jar"

      - name: Deploy on server (key-only)
        if: steps.tcp.outputs.ok == 'true' || steps.tcp.outputs.ok2 == 'true'
        shell: bash
        run: |
          set -euo pipefail
          HOST="${{ secrets.SSH_HOST }}"
          PORT="${{ secrets.SSH_PORT }}"
          USER="${{ secrets.SSH_USER }}"

          SIM_FAIL="${{ github.event.inputs.simulate_cd_fail || 'false' }}"

          ssh -v -p "${PORT}" \
            -i ~/.ssh/deploy_key \
            -o BatchMode=yes \
            -o ConnectTimeout=10 \
            -o StrictHostKeyChecking=accept-new \
            "${USER}@${HOST}" "
              set -euo pipefail
              echo 'incoming listing:'
              ls -al /opt/githubactionPractice/incoming

              if [ '${SIM_FAIL}' = 'true' ]; then
                echo 'simulate_cd_fail=true -> forcing failure'
                exit 1
              fi

              # 권한/실행 문제 대비: bash로 직접 실행도 가능
              sudo /usr/local/bin/deploy_githubactionPractice.sh

              echo 'service status:'
              sudo systemctl status githubactionPractice --no-pager -l || true
            "

      - name: If TCP failed, explain next step
        if: steps.tcp.outputs.ok != 'true' && steps.tcp.outputs.ok2 != 'true'
        shell: bash
        run: |
          echo "TCP to SSH port is NOT reachable from GitHub-hosted runner."
          echo "This is not an SSH key problem. It's network/firewall/ISP/geo-block/NAT allowlist."
          exit 1
